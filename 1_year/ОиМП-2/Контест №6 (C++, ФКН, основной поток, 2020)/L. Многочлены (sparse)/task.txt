

L. Многочлены (sparse)


Ограничение времени
1 секунда


Ограничение памяти
64Mb


Ввод
стандартный ввод или input.txt


Вывод
стандартный вывод или output.txt





Отличие от предыдущей задачи в том, что надо изменить способ хранения коэффициентов многочлена в памяти. 

Реализуйте шаблонный класс Polynomial (многочлен от одной переменной). Тип коэффициентов многочлена передавайте в качестве параметра шаблона. Хранение коэффициентов
         должно быть разреженным (то есть в памяти должны храниться только ненулевые коэффициенты с указанием соответствующей степени). 
      
Сделайте следующее: 
1. Напишите конструкторы: 
         
создающий многочлен по заданному вектору коэффициентов (коэффициенты задаются от младшего к старшим). 
создающий многочлен по заданному коэффициенту (многочлен нулевой степени), который по умолчанию равен значению по умолчанию
               параметра шаблона. 
            
создающий многочлен по заданным итераторам на начало и следующий за концом последовательности коэффициентов (аналогично, от
               младшего к старшим). 
            


2. Перегрузите операторы == и !=. Ваш код должен быть очень простым. Операторы должны работать и в том случае, когда один из аргументов является скаляром.
         
      
3. Перегрузите операторы +, - и *, а также соответствующие операторы +=, -= и *=. Учтите, что должны быть определены и такие арифметические операции, в которых один из аргументов является скаляром. 
      
4. Перегрузите оператор [] для получения коэффициента многочлена перед заданной степенью переменной. Достаточно константной версии этого оператора.
         Оператор должен работать для любых степеней (в том числе больших текущей максимальной). Напишите также метод Degree для вычисления степени многочлена (считайте, что у нулевого многочлена степень равна -1). 
      
5. Перегрузите оператор () для вычисления значения многочлена в точке. Постарайтесь написать эффективный код. 
      
6. Перегрузите оператор << для печати многочлена в поток вывода. При этом следует учитывать знаки коэффициентов, совпадение коэффициентов с 1 или -1,
         степень монома и т. д. Печататься должны только ненулевые коэффициенты многочлена начиная со старшей степени. Нулевой многочлен
         должен печататься так же, как и нулевой коэффициент. Пример формата вывода: -x^3+4*x^2+x-1. 
      
7. Предусмотрите методы begin() и end() для доступа к константным итераторам. Итератор должен адресовывать пару (показатель
         степени, ненулевой коэффициент). Пары должны возвращаться в порядке от младших коэффициентов к старшим. 
      
8. Перегрузите бинарный оператор & для вычисления композиции многочленов: (f & g)(x) должно равняться f(g(x)). 
      
9. Перегрузите операторы / и % для вычисления неполного частного и остатка от деления многочленов (считайте, что в этом случае деление коэффициентов допустимо).
         Перегрузите также оператор «запятая» для вычисления наибольшего общего делителя. Так как НОД многочленов определен с точностью до обратимого коэффициента, считайте,
         что его старший коэффициент равен единице. Считайте также, что все операции деления над коэффициентами выполняются точно.
         
      
Обратите внимание, что все методы, не изменяющие состояние объекта (вроде Degree, (), [] и т.д.) обязаны быть константными. То же касается и аргументов операций +, - и т.д.. Например, если x и y это const Polynomial<int>,
         то x.Degree(), x + y и т.д. должно компилироваться. Разумеется, это не относится к += и подобным операциям, изменяющим сам
         объект. 
      
Также обратите внимание, что оператор << должен возвращать ссылку на std::ostream, что позволяет писать, например так: 
      
std::cout << x << " " << y << std::endl;
      

Примечания

В вашем решении должен быть только код класса и не должно быть функции main. При проверке наша программа будет использовать
            ваш класс Polynomial. Она сама прочитает с входного потока коэффициенты многочленов и выведет их сумму, разность, произведение и т. д.
         
