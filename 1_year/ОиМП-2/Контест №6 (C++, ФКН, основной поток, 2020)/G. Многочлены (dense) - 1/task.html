<div class="problem-statement">
<div class="header">
<h1 class="title">G. Многочлены (dense) - 1</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Реализуйте шаблонный класс <span style=""><span style="font-weight:bold;">Polynomial</span></span> (многочлен от одной переменной) на основе контейнера std::vector. Тип коэффициентов многочлена передавайте в качестве параметра
            шаблона. Хранение коэффициентов должно быть <span style="font-style:italic;">плотным</span> (то есть должны храниться все коэффициенты, в том числе и промежуточные нулевые). 
         </p></span><p>Сделайте следующее: </p>
<p>1. Напишите конструкторы: 
         <ul>
<li>создающий многочлен по заданному вектору коэффициентов (коэффициенты задаются от младшего к старшим). </li>
<li>создающий многочлен по заданному коэффициенту (многочлен нулевой степени), который по умолчанию равен значению по умолчанию
               параметра шаблона. 
            </li>
<li>создающий многочлен по заданным итераторам на начало и следующий за концом последовательности коэффициентов (аналогично, от
               младшего к старшим). 
            </li>
</ul>
</p>
<p>2. Перегрузите операторы <span style=""><span style="font-weight:bold;">==</span></span> и <span style=""><span style="font-weight:bold;">!=</span></span>. Ваш код должен быть очень простым. Операторы должны работать и в том случае, когда один из аргументов является скаляром.
         
      </p>
<p>3. Перегрузите операторы <span style=""><span style="font-weight:bold;">+</span></span>, <span style=""><span style="font-weight:bold;">-</span></span> и <span style=""><span style="font-weight:bold;">*</span></span>, а также соответствующие операторы <span style=""><span style="font-weight:bold;">+=</span></span>, <span style=""><span style="font-weight:bold;">-=</span></span> и <span style=""><span style="font-weight:bold;">*=</span></span>. Учтите, что должны быть определены и такие арифметические операции, в которых один из аргументов является скаляром. 
      </p>
<p>4. Перегрузите оператор <span style=""><span style="font-weight:bold;"><span style="">[]</span></span></span> для получения коэффициента многочлена перед заданной степенью переменной. Достаточно константной версии этого оператора.
         Оператор должен работать для любых степеней (в том числе больших текущей максимальной). Напишите также метод <span style=""><span style="font-weight:bold;">Degree</span></span> для вычисления степени многочлена (считайте, что у нулевого многочлена степень равна -1). 
      </p>
<p>5. Перегрузите оператор <span style=""><span style="font-weight:bold;">()</span></span> для вычисления значения многочлена в точке. В качестве аргумента этот оператор принимает значение того типа, от которого
         создан многочлен. Постарайтесь написать эффективный код. 
      </p>
<p>6. Перегрузите оператор <span style=""><span style="font-weight:bold;"><span style="">&lt;</span><span style="">&lt;</span></span></span> для печати многочлена в поток вывода. При этом следует учитывать знаки коэффициентов, совпадение коэффициентов с 1 или -1,
         степень монома и т. д. Печататься должны только ненулевые коэффициенты многочлена начиная со старшей степени. Нулевой многочлен
         должен печататься так же, как и нулевой коэффициент. Пример формата вывода: -x^3+4*x^2+x-1. 
      </p>
<p>7. Предусмотрите методы begin() и end() для доступа к константным итераторам, позволяющим перебрать коэффициенты многочлена
         (это могут быть просто итераторы вектора). При этом ведущие нули коэффициентами не считаются. Итерация должна происходить
         от младших коэффициентов к старшим. 
      </p>
<p>8. Перегрузите бинарный оператор <span style=""><span style="font-weight:bold;">&amp;</span></span> для вычисления композиции многочленов: (f &amp; g)(x) должно равняться f(g(x)). 
      </p>
<p>9. Перегрузите операторы <span style=""><span style="font-weight:bold;">/</span></span> и <span style=""><span style="font-weight:bold;">%</span></span> для вычисления неполного частного и остатка от деления многочленов (считайте, что в этом случае деление коэффициентов допустимо).
         Перегрузите также оператор «запятая» для вычисления наибольшего общего делителя. Так как НОД многочленов определен с точностью до обратимого коэффициента, считайте,
         что его старший коэффициент равен единице. Считайте также, что все операции деления над коэффициентами выполняются точно.
         
      </p>
<p>Обратите внимание, что все методы, не изменяющие состояние объекта (вроде Degree, (), <span style="">[]</span> и т.д.) обязаны быть константными. То же касается и аргументов операций +, - и т.д.. Например, если x и y это const Polynomial&lt;int&gt;,
         то x.Degree(), x + y и т.д. должно компилироваться. Разумеется, это не относится к += и подобным операциям, изменяющим сам
         объект. 
      </p>
<p>Также обратите внимание, что оператор <span style="">&lt;</span><span style="">&lt;</span> должен возвращать ссылку на std::ostream, что позволяет писать, например так: 
      </p>
<p>std::cout <span style="">&lt;</span><span style="">&lt;</span> x <span style="">&lt;</span><span style="">&lt;</span> " " <span style="">&lt;</span><span style="">&lt;</span> y <span style="">&lt;</span><span style="">&lt;</span> std::endl;
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>В вашем решении должен быть только код класса и не должно быть функции main. При проверке наша программа будет использовать
            ваш класс <span style=""><span style="font-weight:bold;">Polynomial</span></span>. Она сама прочитает с входного потока коэффициенты многочленов и выведет их сумму, разность, произведение и т. д. 
         </p></span><p>Эта задача разбита на 5 подзадач, в которых проверяется следующее: 
         <ol>
<li>Реализованы конструкторы, +, -, +=, -=, ==, !=, <span style="">[ ]</span>, Degree, begin, end. 
            </li>
<li>+ реализованы *, *=, (). </li>
<li>+ реализован вывод через <span style="">&lt;</span><span style="">&lt;</span>. 
            </li>
<li>+ реализован оператор композиции &amp;. </li>
<li>+ реализованы /, %, НОД. </li>
</ol>
</p>
<p>Обратите внимание, что если какой-то из операторов реализован в вашем решении, но при этом его вызов не компилируется (т.
         е. реализован неправильно), то вы будете получать не ошибку компиляции, а неправильный ответ, так как тестирующая программа
         доопределяет те операторы, вызов которых не компилируется. 
      </p>
<p>Вы можете считать, что шаблонный параметр — это числовой тип, для которого реализованы все арифметические операции, операции сравнения и вывод в поток. Также переменную
         этого типа можно сконструировать от int. Обратите внимание, что наличие неявного конструктора и оператора приведения типа
         <span style=""><span style="font-weight:bold;">не гарантируется</span></span>: необходимо вызывать конструктор явно.
      </p>
</div>
</div>