

G. Многочлены (dense) - 1


Ограничение времени
1 секунда


Ограничение памяти
64Mb


Ввод
стандартный ввод или input.txt


Вывод
стандартный вывод или output.txt





Реализуйте шаблонный класс Polynomial (многочлен от одной переменной) на основе контейнера std::vector. Тип коэффициентов многочлена передавайте в качестве параметра
            шаблона. Хранение коэффициентов должно быть плотным (то есть должны храниться все коэффициенты, в том числе и промежуточные нулевые). 
         Сделайте следующее: 
1. Напишите конструкторы: 
         
создающий многочлен по заданному вектору коэффициентов (коэффициенты задаются от младшего к старшим). 
создающий многочлен по заданному коэффициенту (многочлен нулевой степени), который по умолчанию равен значению по умолчанию
               параметра шаблона. 
            
создающий многочлен по заданным итераторам на начало и следующий за концом последовательности коэффициентов (аналогично, от
               младшего к старшим). 
            


2. Перегрузите операторы == и !=. Ваш код должен быть очень простым. Операторы должны работать и в том случае, когда один из аргументов является скаляром.
         
      
3. Перегрузите операторы +, - и *, а также соответствующие операторы +=, -= и *=. Учтите, что должны быть определены и такие арифметические операции, в которых один из аргументов является скаляром. 
      
4. Перегрузите оператор [] для получения коэффициента многочлена перед заданной степенью переменной. Достаточно константной версии этого оператора.
         Оператор должен работать для любых степеней (в том числе больших текущей максимальной). Напишите также метод Degree для вычисления степени многочлена (считайте, что у нулевого многочлена степень равна -1). 
      
5. Перегрузите оператор () для вычисления значения многочлена в точке. В качестве аргумента этот оператор принимает значение того типа, от которого
         создан многочлен. Постарайтесь написать эффективный код. 
      
6. Перегрузите оператор << для печати многочлена в поток вывода. При этом следует учитывать знаки коэффициентов, совпадение коэффициентов с 1 или -1,
         степень монома и т. д. Печататься должны только ненулевые коэффициенты многочлена начиная со старшей степени. Нулевой многочлен
         должен печататься так же, как и нулевой коэффициент. Пример формата вывода: -x^3+4*x^2+x-1. 
      
7. Предусмотрите методы begin() и end() для доступа к константным итераторам, позволяющим перебрать коэффициенты многочлена
         (это могут быть просто итераторы вектора). При этом ведущие нули коэффициентами не считаются. Итерация должна происходить
         от младших коэффициентов к старшим. 
      
8. Перегрузите бинарный оператор & для вычисления композиции многочленов: (f & g)(x) должно равняться f(g(x)). 
      
9. Перегрузите операторы / и % для вычисления неполного частного и остатка от деления многочленов (считайте, что в этом случае деление коэффициентов допустимо).
         Перегрузите также оператор «запятая» для вычисления наибольшего общего делителя. Так как НОД многочленов определен с точностью до обратимого коэффициента, считайте,
         что его старший коэффициент равен единице. Считайте также, что все операции деления над коэффициентами выполняются точно.
         
      
Обратите внимание, что все методы, не изменяющие состояние объекта (вроде Degree, (), [] и т.д.) обязаны быть константными. То же касается и аргументов операций +, - и т.д.. Например, если x и y это const Polynomial<int>,
         то x.Degree(), x + y и т.д. должно компилироваться. Разумеется, это не относится к += и подобным операциям, изменяющим сам
         объект. 
      
Также обратите внимание, что оператор << должен возвращать ссылку на std::ostream, что позволяет писать, например так: 
      
std::cout << x << " " << y << std::endl;
      

Примечания

В вашем решении должен быть только код класса и не должно быть функции main. При проверке наша программа будет использовать
            ваш класс Polynomial. Она сама прочитает с входного потока коэффициенты многочленов и выведет их сумму, разность, произведение и т. д. 
         Эта задача разбита на 5 подзадач, в которых проверяется следующее: 
         
Реализованы конструкторы, +, -, +=, -=, ==, !=, [ ], Degree, begin, end. 
            
+ реализованы *, *=, (). 
+ реализован вывод через <<. 
            
+ реализован оператор композиции &. 
+ реализованы /, %, НОД. 


Обратите внимание, что если какой-то из операторов реализован в вашем решении, но при этом его вызов не компилируется (т.
         е. реализован неправильно), то вы будете получать не ошибку компиляции, а неправильный ответ, так как тестирующая программа
         доопределяет те операторы, вызов которых не компилируется. 
      
Вы можете считать, что шаблонный параметр — это числовой тип, для которого реализованы все арифметические операции, операции сравнения и вывод в поток. Также переменную
         этого типа можно сконструировать от int. Обратите внимание, что наличие неявного конструктора и оператора приведения типа
         не гарантируется: необходимо вызывать конструктор явно.
      

