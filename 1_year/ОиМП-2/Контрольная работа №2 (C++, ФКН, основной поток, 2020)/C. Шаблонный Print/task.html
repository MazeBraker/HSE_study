<div class="problem-statement">
<div class="header">
<h1 class="title">C. Шаблонный Print</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Вам надо написать функцию Print, которая умеет печатать в поток std::cout элементы переданного контейнера через указанную
            строку-разделитель. Первый аргумент функции — контейнер. Туда может быть передан и вектор, и дек, и список, и строка, и любой другой подходящий контейнер. Гарантируется,
            что по этому контейнеру можно проитерироваться с помощью стандартного цикла range-based for, и что элементы контейнера можно
            напечатать в поток cout с помощью стандартного оператора <span style="">&lt;</span><span style="">&lt;</span>. Второй аргумент функции — строка-разделитель, которую надо печатать между элементами. В конце надо напечатать перевод строки '\n'. Вызывать вашу функцию
            мы будем примерно так: 
         </p></span><p>std::vector&lt;int&gt; data = {1, 2, 3}; <br/> Print(data, ", "); 
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Сдайте в систему только код функции Print без функции main. Подключите все необходимые для вашей реализации библиотеки. Используйте
            константные ссылки для получения параметров и при итерации в цикле, чтобы избежать лишних копирований: если этого не сделать,
            то программа не скомпилируется.
         </p></span></div>
</div>