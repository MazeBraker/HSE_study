<div class="problem-statement">
<div class="header">
<h1 class="title">P. UniquePtr-1</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Напишите свою упрощённую реализацию класса std::unique_ptr&lt;T&gt;. </p></span><p>Подробную спецификацию стандартного std::unique_ptr можно посмотреть на <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">http://en.cppreference.com/w/cpp/memory/unique_ptr</a>. В этой задаче вам не нужно делать специализацию для массива и не нужно предусматривать свой Deleter. 
      </p>
<p>Назовите ваш класс UniquePtr. У класса должен быть один шаблонный параметр T - тип элемента, указатель на который будет храниться
         внутри. 
      </p>
<p>Напишите следующие функции в классе: </p>
<p>
<ol>
<li>Конструктор по умолчанию, создающий пустой умный указатель. </li>
<li>Конструктор, принимающий T * и захватывающий владение этой динамической памятью. </li>
<li>Конструктор перемещения, получающий на вход rvalue-ссылку на другой UniquePtr и отбирающий у него владение ресурсом. </li>
<li>Оператор присваивания, получающий на вход nullptr (тип - std::nullptr_t, определенный в заголовочном файле cstddef). В результате
               умный указатель должен стать пустым. 
            </li>
<li>Move-оператор присваивания, получающий на вход rvalue-ссылку на другой UniquePtr. </li>
<li>Деструктор. </li>
<li>Константный оператор *. </li>
<li>Константный оператор -&gt; (он должен вернуть просто сам указатель). </li>
<li>Функцию T * release(), отменяющую владение объектом и возвращающую хранящийся внутри указатель. </li>
<li>Функцию void reset(T * ptr), после выполнения которой умный указатель должен захватить ptr. </li>
<li>Функцию void swap(UniquePtr&amp; other), обменивающуюся содержимым с другим умным указателем. </li>
<li>Функцию T * get() const, возвращающую указатель. </li>
<li>explicit operator bool() const, позволяющий определить, не пуст ли умный указатель. </li>
</ol>
</p>
<p>В вашем классе должны быть запрещены конструктор копирования и обычный оператор присваивания. Пометьте все подходящие функции
         тегом noexcept (чтобы подчеркнуть, что они не должны генерировать исключений). 
      </p>
<p>sizeof вашего класса должен совпадать с sizeof от обычного указателя, а дополнительной динамической памяти внутри UniquePtr
         выделяться не должно. То есть UniquePtr не должен иметь накладных расходов на память по сравнению с обычным указателем.
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Сдайте только код самого класса без функции main. Использовать стандартный std::unique_ptr запрещается.</p></span></div>
</div>