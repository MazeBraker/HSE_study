<div class="problem-statement">
<div class="header">
<h1 class="title">J. Varint</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>В протоколе Protocol Buffers для кодирования чисел используется кодировка Varint (<a href="https://clck.ru/CJL7L">https://clck.ru/CJL7L</a>). Эта кодировка позволяет кодировать маленькие числа меньшим количеством байт. Пусть дано неотрицательное целое число, помещающееся
            в тип uint64_t. Чтобы закодировать его в Varint, надо разбить его двоичную запись на блоки по 7 бит, начиная с младших (правых)
            битов. Эти блоки рассматриваются справа налево, от младших битов к старшим. Очередной закодированный байт получается из очередного
            блока, к которому приписывается ведущая единица, если это не последний байт, и ведущий ноль, если это последний байт. 
         </p></span><p>Например, закодируем число 300. В двоичной системе оно выглядит как 100101100. Тут два блока: 10 и 0101100. Сначала выпишем
         правый блок (с ведущей единицей) - 10101100, затем левый блок, дополненный нулями - 00000010. Аналогично, число 31415, записываемое
         в двоичной системе как 111101010110111, закодируется как 10110111 11110101 00000001. 
      </p>
<p>Вам даны байты закодированного числа. Раскодируйте его.</p>
</div>
<h2>Формат ввода</h2>
<div class="input-specification"><span style="">
<p>На вход поступают байты закодированного числа. Гарантируется, что ответ может быть записан в тип данных uint64_t. Удобно прочитать
            эти байты целиком в std::string, а дальше итерироваться по ним с помощью типа unsigned char или uint8_t.
         </p></span></div>
<h2>Формат вывода</h2>
<div class="output-specification"><span style="">
<p>Напечатайте число, которое было закодировано.</p></span></div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Обратите внимание, что на вход данные не в текстовой записи (не 10101010 11010101), а в бинарном виде, байтами. Правильный
            способ их чтения такой: 
         </p></span><p>std::string s; </p>
<p>getline(std::cin, s); </p>
<p>for (uint8_t byte : s) // do something with byte </p>
</div>
</div>