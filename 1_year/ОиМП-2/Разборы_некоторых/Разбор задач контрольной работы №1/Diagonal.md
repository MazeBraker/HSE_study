## Разбор задачи "Диагональ"

### Условие
Реализуйте функцию с заголовком
```cpp
bool CheckAntiDiagonalSymmetry(const std::vector<std::vector<int>>& matrix);
```
Функция принимает квадратную матрицу и возвращает `true`, если матрица является симметричной относительно побочной диагонали, и `false` иначе.

Гарантируется, что матрица является квадратной размера n × n, где 0 ≤ n ≤ 100.

Побочная диагональ матрицы - это диагональ, проходящая из левого нижнего угла в правый верхний (при условии, что индексы строк и столбцов нумеруются сверху вниз и слева направо).
В вашем решении должна быть только эта функция и необходимые директивы `#include`. Мы сами протестируем её работу с помощью своей функции `main`.

### Решение
Сначала надо понять, как для элемента с индексами `i, j` найти индексы симметричного элемента.
Это будут индексы `matrix.size() - 1 - j` и `matrix.size() - 1 - i`.
Вычитание единицы возникает из-за того, что индексы нумеруются с нуля.

Теперь самое простое решение - проверить для каждого элемента матрицы что он равен симметричному:
```cpp
#include <vector>

bool CheckAntiDiagonalSymmetry(const std::vector<std::vector<int>>& matrix) {
    for (size_t i = 0; i != matrix.size(); ++i) {
        for (size_t j = 0; j != matrix.size(); ++j) {
            if (matrix[i][j] != matrix[matrix.size() - 1 - j][matrix.size() - 1 - i]) {
                return false;
            }
        }
    }
    return true;
}
```

Конечно, можно уменьшить перебор в два раза: достаточно перебирать только элементы, лежащие выше побочной диагонали.
Напишите такой вариант сами.

Типичная ошибка здесь у многих - ограничиваться только элементами выше главной диагонали:
```cpp
    for (size_t i = 0; i != matrix.size(); ++i) {
        for (size_t j = 0; j != i; ++j) {  // ошибка!
            // ...
        }
    }
```