<div class="problem-statement">
<div class="header">
<h1 class="title">H. SharedPtr</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Напишите свою упрощённую реализацию класса std::shared_ptr&lt;T&gt;. </p></span><p>Подробную спецификацию стандартного std::shared_ptr можно посмотреть на <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">http://en.cppreference.com/w/cpp/memory/shared_ptr</a>. В этой задаче вам не нужно делать специализацию для массива и не нужно предусматривать свой Deleter. 
      </p>
<p>Назовите ваш класс SharedPtr. У класса должен быть один шаблонный параметр T – тип элемента, указатель на который будет храниться внутри. </p>
<p>Напишите следующие функции в классе: </p>
<p>
<ol>
<li>Конструктор по умолчанию, создающий пустой умный указатель. </li>
<li>Конструктор, принимающий T * и захватывающий владение этой динамической памятью. </li>
<li>Конструктор копирования, принимающий на вход другой аналогичный SharedPtr и увеличивающий счётчик ссылок на данный объект.
               
            </li>
<li>Конструктор перемещения, получающий на вход rvalue-ссылку на другой SharedPtr и отбирающий у него владение ресурсом. </li>
<li>Оператор присваивания, получающий на вход указатель. В результате счётчик ссылок на текущий объект должен уменьшиться, а SharedPtr
               должен захватить владение переданным указателем. 
            </li>
<li>Оператор присваивания, получающий на вход другой SharedPtr. В результате счётчик ссылок на текущий объект должен уменьшиться,
               а SharedPtr должен присоединиться к владению переданным указателем. 
            </li>
<li>Move-оператор присваивания, получающий на вход rvalue-ссылку на другой SharedPtr. Этот оператор должен немедленно уничтожать
               ссылку на старый объект (аналогично стандартному std::shared_ptr) 
            </li>
<li>Деструктор. </li>
<li>Константный и неконстантный оператор *. </li>
<li>Оператор -&gt;. </li>
<li>Функцию void reset(T * ptr), после выполнения которой умный указатель должен уменьшить счётчик ссылок и захватить ptr. </li>
<li>Функцию void swap(SharedPtr&amp; other), обменивающуюся содержимым с другим умным указателем. </li>
<li>Функцию T * get() const, возвращающую указатель. </li>
<li>explicit operator bool() const, позволяющий определить, не пуст ли умный указатель. </li>
</ol>
</p>
<p>Пометьте все подходящие функции тегом noexcept (чтобы подчеркнуть, что они не должны генерировать исключений). </p>
<p>В вашей программе не должно быть утечек памяти. Объект, которым владеет SharedPtr, должен быть удален тогда и только тогда,
         когда будет уничтожен последний SharedPtr, владеющий им.
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Сдайте только код самого класса без функции main. Использовать стандартный std::shared_ptr запрещается. </p></span><p>Мы будем тестировать ваш класс с помощью вот такого кода: <a href="https://clck.ru/FN2WS">https://clck.ru/FN2WS</a>.
      </p>
</div>
</div>