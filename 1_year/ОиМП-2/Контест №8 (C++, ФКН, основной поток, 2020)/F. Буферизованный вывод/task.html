<div class="problem-statement">
<div class="header">
<h1 class="title">F. Буферизованный вывод</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Вам дан класс Writer, который умеет писать данные на экран, в файл или в память – в общем, неважно куда. У этого класса есть виртуальная функция Write, принимающая на вход указатель на байты памяти и их
            количество. Функция пытается записать эти байты в нужное место. Выглядит этот класс примерно так: <a href="https://clck.ru/CbtZu">https://clck.ru/CbtZu</a>. 
         </p></span><p>Однако операция вывода имеет накладные расходы, и частые вызовы Write с маленькими размерами данных могут замедлять программу.
         Вам надо написать класс-наследник BufferedWriter, который осуществлял бы буферизованный вывод. Конструктор этого класса должен
         принимать параметр типа size_t – размер буфера. Переопределенная в этом классе функция Write должна сначала дописывать данные в этот внутренний буфер, и только
         когда он заполнится – вызывать Write базового класса с данными этого буфера. В конце использования класса оставшиеся в буфере данные также должны
         быть записаны через вызов функции Write базового класса. Максимально возможный размер буфера, переданный в конструкторе, в
         процессе работы не должен изменяться.
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Начните свою программу с #include "writer.h" – эта директива подключит нашу версию базового класса Writer. Далее напишите только код класса-наследника BufferedWriter.</p></span></div>
</div>