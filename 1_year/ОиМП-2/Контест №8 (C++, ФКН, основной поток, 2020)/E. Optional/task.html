<div class="problem-statement">
<div class="header">
<h1 class="title">E. Optional</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Напишите свою реализацию класса std::optional (<a href="https://en.cppreference.com/w/cpp/utility/optional">https://en.cppreference.com/w/cpp/utility/optional</a>), который может либо хранить элемент, либо хранить метку об отсутствии элемента. 
         </p></span><p>Вот заготовка для вашего класса: <a href="https://clck.ru/FLoZE">https://clck.ru/FLoZE</a>. Вам нужно вписать сюда реализацию функций класса и сдать класс с функциями в систему. 
      </p>
<p>Обратите внимание, что Optional, в отличие от unique_ptr, должен хранить данные на стеке, а не в динамической памяти. Эти
         данные нужно проинициализировать только при необходимости (по умолчанию Optional создаётся пустым). Для этого нужно использовать
         конструкцию placement new - явное указание компилятору создать объект в указанном месте памяти. Например, сконструировать
         новый объект типа T в блоке памяти data можно так: new (data) T(). За временем жизни такого объекта придётся следить самостоятельно.
         Сама сырая память data в данном случае будет удалена автоматически, но деструктор придётся позвать вручную: reinterpret_cast&lt;T*&gt;(data)-&gt;<span class="tex-math-inline"><img class="tex-math" src="/testsys/tex/render/XHNpbQ==.png"/></span>T(). Запомните: конструирование объекта с помощью placement new в уже имеющейся памяти, как в этой задаче, - это единственный
         случай, когда которого нужно вызывать деструктор самостоятельно. 
      </p>
<p>Пытайтесь не создавать лишние объекты типа T зря. Например, при присваивании нового объекта уже заполненному Optional просто
         вызовите соответствующий оператор присваивания для типа T. 
      </p>
<p>Вот код нашей тестовой программы, который вам поможет в отладке: <a href="https://clck.ru/FLoZo">https://clck.ru/FLoZo</a>. Вы можете сравнить её вывод для вашего класса и для стандартного std::optional.
      </p>
</div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Заметим, что настоящий std::optional реализован сложнее. Просто конструировать объект в буфере байт на стеке он не может:
            тогда такой std::optional нельзя было бы использовать в constexpr-выражениях. Вместо этого в стандартном std::optional применяется
            union. Однако в этой задаче вполне достаточно использовать обычный буфер. 
         </p></span><p>Не пытайтесь использовать в своём решении стандартный std::optional: это не скомпилируется.</p>
</div>
</div>