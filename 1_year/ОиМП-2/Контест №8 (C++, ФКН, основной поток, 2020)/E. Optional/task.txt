

E. Optional


Ограничение времени
1 секунда


Ограничение памяти
64Mb


Ввод
стандартный ввод или input.txt


Вывод
стандартный вывод или output.txt





Напишите свою реализацию класса std::optional (https://en.cppreference.com/w/cpp/utility/optional), который может либо хранить элемент, либо хранить метку об отсутствии элемента. 
         Вот заготовка для вашего класса: https://clck.ru/FLoZE. Вам нужно вписать сюда реализацию функций класса и сдать класс с функциями в систему. 
      
Обратите внимание, что Optional, в отличие от unique_ptr, должен хранить данные на стеке, а не в динамической памяти. Эти
         данные нужно проинициализировать только при необходимости (по умолчанию Optional создаётся пустым). Для этого нужно использовать
         конструкцию placement new - явное указание компилятору создать объект в указанном месте памяти. Например, сконструировать
         новый объект типа T в блоке памяти data можно так: new (data) T(). За временем жизни такого объекта придётся следить самостоятельно.
         Сама сырая память data в данном случае будет удалена автоматически, но деструктор придётся позвать вручную: reinterpret_cast<T*>(data)->T(). Запомните: конструирование объекта с помощью placement new в уже имеющейся памяти, как в этой задаче, - это единственный
         случай, когда которого нужно вызывать деструктор самостоятельно. 
      
Пытайтесь не создавать лишние объекты типа T зря. Например, при присваивании нового объекта уже заполненному Optional просто
         вызовите соответствующий оператор присваивания для типа T. 
      
Вот код нашей тестовой программы, который вам поможет в отладке: https://clck.ru/FLoZo. Вы можете сравнить её вывод для вашего класса и для стандартного std::optional.
      

Примечания

Заметим, что настоящий std::optional реализован сложнее. Просто конструировать объект в буфере байт на стеке он не может:
            тогда такой std::optional нельзя было бы использовать в constexpr-выражениях. Вместо этого в стандартном std::optional применяется
            union. Однако в этой задаче вполне достаточно использовать обычный буфер. 
         Не пытайтесь использовать в своём решении стандартный std::optional: это не скомпилируется.

