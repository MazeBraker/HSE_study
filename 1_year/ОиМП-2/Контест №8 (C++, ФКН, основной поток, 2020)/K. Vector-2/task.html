<div class="problem-statement">
<div class="header">
<h1 class="title">K. Vector-2</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>1 секунда</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>64Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>Реализуйте свой класс Vector&lt;T&gt;, аналогичный std::vector&lt;T&gt;. В отличие от задачи Vector-1 класс должен быть шаблонным и должен
            работать с любым типом T, имеющим конструктор по умолчанию, конструктор копирования и деструктор. Дополните набор функций
            предыдущей задачи функциями capacity, reserve, resize, clear, swap, begin, end. В качестве итераторов вектора можно использовать
            обычные указатели. Обратите внимание, что вектор должен резервировать «сырую» память, и конструировать элементы в ней только при необходимости. Ваш класс должен непосредственно работать с динамической
            памятью: пользоваться аналогичными классами стандартной библиотеки запрещено.
         </p></span></div>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Обратите внимание на следующие особенности: </p></span><p>
<ol>
<li>Конструктор без параметров не должен резервировать память для вектора. </li>
<li>Конструктор с одним параметром (размером вектора) должен резервировать память ровно указанного объёма. </li>
<li>Конструктор копирования должен резервировать ровно столько памяти, сколько требуется для хранения элементов. </li>
<li>При возникновении исключений в функциях шаблонного типа T не должно происходить утечек памяти. </li>
<li>При реаллокации в функции push_back пустой вектор должен приобрести ёмкость 1, а вектор ненулевой ёмкости должен удвоить свою
               ёмкость. 
            </li>
<li>Если ёмкости вектора в функции resize не хватает, то при реаллокации вектор должен приобрести минимально возможную необходимую
               ёмкость. 
            </li>
<li>Функция reserve и оператор присваивания должны давать строгие гарантии безопасности: если при реаллокации произошел сбой,
               то вектор не должен изменить своего состояния. 
            </li>
<li>Функции resize и push_back должны давать базовую гарантию безопасности: если при добавлении элемента произошел сбой, то состояние
               вектора может измениться, но оно должно быть согласованным. 
            </li>
<li>Функция push_back должна иметь перегруженную версию, принимающую на вход rvalue-ссылку T&amp;&amp;. </li>
<li>Вызовы деструкторов для элементов должны происходить в прямом порядке (начиная с первого элемента). </li>
<li>Мы компилируем вашу программу с опцией -fsanitize=address, чтобы обнаружить возможные утечки памяти. Кроме того, мы при тестировании
               используем ваш вектор с элементами нашего класса C, который печатает в своих конструкторах, операторах присваивания и деструкторах
               сообщения о вызове. Поведение вашего класса должно быть таким же, как и стандартного вектора. 
            </li>
</ol>
</p>
<p>Вот код, похожий на тот, с помощью которого мы будем тестировать ваш класс: <a href="https://clck.ru/MNrCi">https://clck.ru/MNrCi</a>. 
      </p>
<p>Реализации стандартного вектора могут отличаться, поэтому выкладываем ожидаемый вывод для данного тестового кода: <a href="https://clck.ru/MNrEF">https://clck.ru/MNrEF</a>. 
      </p>
</div>
</div>