

K. Vector-2


Ограничение времени
1 секунда


Ограничение памяти
64Mb


Ввод
стандартный ввод или input.txt


Вывод
стандартный вывод или output.txt





Реализуйте свой класс Vector<T>, аналогичный std::vector<T>. В отличие от задачи Vector-1 класс должен быть шаблонным и должен
            работать с любым типом T, имеющим конструктор по умолчанию, конструктор копирования и деструктор. Дополните набор функций
            предыдущей задачи функциями capacity, reserve, resize, clear, swap, begin, end. В качестве итераторов вектора можно использовать
            обычные указатели. Обратите внимание, что вектор должен резервировать «сырую» память, и конструировать элементы в ней только при необходимости. Ваш класс должен непосредственно работать с динамической
            памятью: пользоваться аналогичными классами стандартной библиотеки запрещено.
         
Примечания

Обратите внимание на следующие особенности: 

Конструктор без параметров не должен резервировать память для вектора. 
Конструктор с одним параметром (размером вектора) должен резервировать память ровно указанного объёма. 
Конструктор копирования должен резервировать ровно столько памяти, сколько требуется для хранения элементов. 
При возникновении исключений в функциях шаблонного типа T не должно происходить утечек памяти. 
При реаллокации в функции push_back пустой вектор должен приобрести ёмкость 1, а вектор ненулевой ёмкости должен удвоить свою
               ёмкость. 
            
Если ёмкости вектора в функции resize не хватает, то при реаллокации вектор должен приобрести минимально возможную необходимую
               ёмкость. 
            
Функция reserve и оператор присваивания должны давать строгие гарантии безопасности: если при реаллокации произошел сбой,
               то вектор не должен изменить своего состояния. 
            
Функции resize и push_back должны давать базовую гарантию безопасности: если при добавлении элемента произошел сбой, то состояние
               вектора может измениться, но оно должно быть согласованным. 
            
Функция push_back должна иметь перегруженную версию, принимающую на вход rvalue-ссылку T&&. 
Вызовы деструкторов для элементов должны происходить в прямом порядке (начиная с первого элемента). 
Мы компилируем вашу программу с опцией -fsanitize=address, чтобы обнаружить возможные утечки памяти. Кроме того, мы при тестировании
               используем ваш вектор с элементами нашего класса C, который печатает в своих конструкторах, операторах присваивания и деструкторах
               сообщения о вызове. Поведение вашего класса должно быть таким же, как и стандартного вектора. 
            


Вот код, похожий на тот, с помощью которого мы будем тестировать ваш класс: https://clck.ru/MNrCi. 
      
Реализации стандартного вектора могут отличаться, поэтому выкладываем ожидаемый вывод для данного тестового кода: https://clck.ru/MNrEF. 
      

