<div class="problem-statement">
<div class="header">
<h1 class="title">A1. Хеш-таблица</h1>
<table>
<tr class="time-limit">
<td class="property-title">Ограничение времени</td>
<td>2 секунды</td>
</tr>
<tr class="memory-limit">
<td class="property-title">Ограничение памяти</td>
<td>128Mb</td>
</tr>
<tr class="input-file">
<td class="property-title">Ввод</td>
<td colspan="1">стандартный ввод или input.txt</td>
</tr>
<tr class="output-file">
<td class="property-title">Вывод</td>
<td colspan="1">стандартный вывод или output.txt</td>
</tr>
</table>
</div>
<h2></h2>
<div class="legend"><span style="">
<p>В этой задаче, к сожалению, нет увлекательного условия про скатывающийся десант, тараканов и прочее :( </p></span><p>Вам предстоит реализовать упрощенный аналог контейнера std::unordered_map — ассоциативный массив на основе хеш-таблицы, который поддерживает отображение ключ -&gt; значение, т.е. в соответствие каждому
         ключу ставится единственное значение, а все ключи уникальны. Ваша хеш-таблица должна использовать метод цепочек для разрешения
         коллизий. 
      </p>
<p>Вы должны написать шаблон HashMap, который параметризуется типом ключа, типом значения и типом «хешера», иными словами, следующее: </p>
<p>template&lt;class KeyType, class ValueType, class Hash = std::hash&lt;KeyType&gt; &gt; class HashMap; </p>
<p>Скажем пару слов про «хешер». Это некоторый тип, который по ключу типа KeyType умеет выдавать значение типа size_t, которое можно получить, используя
         функциональный вызов. Например: 
      </p>
<p>// пусть hasher имеет тип Hash<br/> KeyType key = ...; // какой-то ключ<br/> size_t num = hasher(key); 
      </p>
<p>Благодаря использованию шаблонов, тип Hash может быть чем угодно — функцией, лямбдой или же классом, для которого перегружен оператор вызова (). Это позволяет пользователю вашего класса выбирать
         наиболее предпочтительный для него вариант хеш-функции. Если же пользователя устраивает стандартный вариант, то используется
         стандартный тип std::hash&lt;KeyType&gt;. 
      </p>
<p>Обратите внимание, что сам по себе хешер всего лишь дает вам возможность получить для любого объекта некоторое число (и предоставляется
         пользователем класса, поскольку вы заранее не знаете, с какими типами будет использоваться ваша таблица), а вот как его использовать
         для организации быстрой хеш-таблицы — уже ваша забота. Однако же если хешер, например, возвращает для всех ключей число 0, то ясно, что это проблема пользователя,
         а от вас мало что зависит. Поэтому вы можете считать, что хешер распределяет ключи по диапазону size_t достаточно равномерно
         (в предположении, что ключи случайны) — в частности, это верно для умолчательного варианта std::hash&lt;KeyType&gt;. 
      </p>
<p>Ваш класс должен содержать следующие конструкторы и методы: 
         <ol>
<li>Конструктор по умолчанию. </li>
<li>Конструктор, принимающий итераторы на начало и конец (точнее, следующий за концом) последовательности, каждый элемент которой
               представляет собой std::pair&lt;ключ, значение&gt;. 
            </li>
<li>Конструктор, принимающий std::initializer_list описанных выше пар. </li>
<li>Все конструкторы также должны поддерживать возможность передачи объекта хешера (т.е. имеющего тип Hash) последним аргументом.
               В случае же, если таковой не передается, то используйте сконструированный по умолчанию. 
            </li>
<li>Методы size и empty, которые должны быть константными, и которые возвращают количество элементов в таблице и пуста ли она
               соответственно. 
            </li>
<li>Константный метод hash_function, который возвращает используемый таблицей хешер по значению. </li>
<li>Метод insert, который принимает std::pair&lt;ключ, значение&gt; и добавляет в таблицу связь ключ -&gt; значение. Если данный ключ уже
               имеется в таблице, то метод не должен ничего делать. 
            </li>
<li>Метод erase, который принимает ключ и удаляет соответствующую пару (ключ, значение) из таблицы. Если искомого ключа нет, то
               метод не должен ничего делать. 
            </li>
<li>Ваш класс должен предоставлять типы iterator и const_iterator, соответствующие итератору и константному итератору, с помощью
               которых можно было бы просмотреть содержимое таблицы, а также соответствующие методы begin и end для обоих типов итераторов,
               возвращающих итератор на начало контейнера и следующий за последним (как все контейнеры стандартной библиотеки). 
               <p>Итератор должен адресовывать значения типа std::pair&lt;const KeyType, ValueType&gt;&amp;, а константный итератор — типа const std::pair&lt;const KeyType, ValueType&gt;&amp;. Таким образом, с помощью обычного итератора можно изменять только значения
                  в таблице (но не ключи), а с помощью константного итератора модификации невозможны совсем. 
               </p>
<p>Обратите внимание, что итерирование по всей таблице должно занимать линейное время по числу вставленных элементов. Однако
                  порядок, в котором перебираются элементы таблицы, может быть произвольным. 
               </p>
<p>Итераторы должны быть, по крайней мере, forward — грубо говоря, поддерживать конструирование, инкремент, разыменовывание (через * и -&gt;), а также операторы сравнения == и !=.
                  Более подробно можно ознакомиться тут: http://www.cplusplus.com/reference/iterator/ForwardIterator/. 
               </p>
<p>Ваш класс может инвалидировать все итераторы после вставок и удалений. Иными словами, если из таблицы удаляется или вставляется
                  элемент, то все имеющиеся на данный момент итераторы могут стать недействительными. Стандартный std::unordered_map при вызове
                  erase инвалидирует только итераторы на удаленный элемент, остальные итераторы остаются действительными. 
               </p>
<p></p>
</li>
<li>Метод find, константный (возвращающий const_iterator) и нет (возвращающий iterator), который по переданному ключу возвращает
               итератор на соответствующую пару (ключ, значение), либо end(), если искомого ключа нет в таблице. 
            </li>
<li>Оператор <span style="">[ ]</span>, который по переданному ключу возвращает ссылку на соответствующее значение. Если же искомого ключа в таблице нет, то метод
               должен добавить в таблицу пару (ключ, значение по умолчанию) и вернуть соответствующую ссылку. Таким образом, можно будет
               писать что-то вроде 
               <p>HashMap&lt;int, int&gt; table;<br/> table<span style="">[3]</span> = 5;<br/> std::cout « table<span style="">[3]</span>; // выведет 5<br/>
</p>
<p></p>
</li>
<li>Константный метод at, который работает аналогично оператору <span style="">[ ]</span>, но возвращает константную ссылку на значение, а при отсутствии ключа генерирует исключение типа std::out_of_range. 
               <p></p>
</li>
<li>Метод clear, который очищает таблицу, удаляя все вставленные элементы. Обратите внимание, что метод должен работать за линейное
               время по количеству элементов в таблице. 
            </li>
</ol>
</p>
<p>Для сравнения ключей используйте только оператор ==. </p>
<p>Если вы используете ручное управление памятью (например, вручную выделяете память через new вместо использования std::vector),
         то, разумеется, ваш класс также должен предоставлять правильно определенные конструктор копирования, оператор присваивания
         и деструктор.
      </p>
</div>
<h2>Формат ввода</h2>
<div class="input-specification"><span style="">
<p>Всего будет не более <span class="tex-math-text">10<sup>6</sup></span> операций с таблицей.
         </p></span></div>
<h2>Пример</h2>
<table class="sample-tests">
<thead>
<tr>
<th>Ввод</th>
<th>Вывод</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre>13
+ 3 5
+ 2 1
+ 0 7
? 0
- 0
? 0
? 2
+ 8 -4
&lt;
!
? 3
+ 3 3
? 3
</pre></td>
<td><pre>7
-1
1
3 5
2 1
8 -4
-1
3
1
</pre></td>
</tr>
</tbody>
</table>
<h2>Примечания</h2>
<div class="notes"><span style="">
<p>Вы должны прислать заголовочный файл, содержащий определение вашего класса. <span style="font-weight:bold;">При сдаче выбирайте компилятор Make</span>. Обратите внимание, что тестирующая программа достаточно строго проверяет требования из условия. В случае их несоблюдения
            вы будете получать вердикт Compile Error (или Runtime Error на 1 тесте). 
         </p></span><p>В примере выше во входных данных вводится число запросов к таблице, далее следуют сами запросы: </p>
<p>+ key value обозначает map<span style="">[key]</span> = value<br/> - key — вызов map.erase(key)<br/> ? key — вывод -1, если ключа нет, и соответствующего данному ключу значения в противном случае.<br/> &lt; — вывод содержимого таблицы в формате «ключ значение».<br/> ! — вызов метода clear.<br/>
</p>
<p>Последнее число в выходных данных — количество элементов в таблице после всех операций.</p>
</div>
</div>